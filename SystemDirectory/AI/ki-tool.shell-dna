#!/bin/bash
# Prototyp 1.0
# ki-tool.shell-dna
# Minimalistisches Bash-Tool für Pylovara: Scannen und Reparieren von Bash-Skripten
# Ort: Pylovara/AI/ki-tool.shell-dna
# Zweck: Pfade korrigieren, Syntax prüfen, .conf-Einbindung sicherstellen
# Nutzung: ki <scan|repair> <Pfad> [Datei]

# Basis-Pfade
PYLOVARA_ROOT="/Pylovara"
MASTER_DIR="${PYLOVARA_ROOT}/SystemControl"
CONTROL_CONF="${MASTER_DIR}/control.pv-conf"
LOG_DIR="${PYLOVARA_ROOT}/Pylovara-Logs/ki-tool"
WIKI_NOTES_DIR="${PYLOVARA_ROOT}/SystemDirectory/FileManager/Basis-Module/Notes/Shell"

# Log- und Fehlerverzeichnis erstellen
mkdir -p "$LOG_DIR"

# Funktion: Loggen in .wiki-notes-Format
log_to_wiki() {
    local message="$1"
    local wiki_file="${WIKI_NOTES_DIR}/ki-tool-log-$(date +%Y%m%d%H%M%S).wiki-notes"
    echo "# KI-Tool Log - $(date)" >> "$wiki_file"
    echo "## Nachricht" >> "$wiki_file"
    echo "$message" >> "$wiki_file"
    echo "[KI-TOOL] Log erstellt: $wiki_file"
}

# Funktion: Pfade in Skripten prüfen und korrigieren
check_and_fix_paths() {
    local file="$1"
    local fixed=false
    local temp_file="${file}.tmp"

    # Prüfen, ob Datei existiert
    if [ ! -f "$file" ]; then
        echo "[KI-TOOL] Fehler: Datei nicht gefunden: $file" >&2
        log_to_wiki "Fehler: Datei nicht gefunden: $file"
        return 1
    fi

    # Pfade relativ zu PYLOVARA_ROOT korrigieren
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*source[[:space:]]+\"?([^\ ]+)\"? ]]; then
            src_path="${BASH_REMATCH[1]}"
            # Prüfen, ob Pfad absolut ist und korrigieren
            if [[ "$src_path" != "$PYLOVARA_ROOT"* ]]; then
                new_path="${PYLOVARA_ROOT}/${src_path#/}"
                if [ -f "$new_path" ]; then
                    echo "[KI-TOOL] Pfad korrigiert: $src_path -> $new_path"
                    line="${line//$src_path/$new_path}"
                    fixed=true
                else
                    echo "[KI-TOOL] Warnung: Zielpfad existiert nicht: $new_path"
                    log_to_wiki "Warnung: Zielpfad existiert nicht: $new_path"
                fi
            fi
        fi
        echo "$line" >> "$temp_file"
    done < "$file"

    # Änderungen übernehmen, wenn nötig
    if [ "$fixed" = true ]; then
        mv "$temp_file" "$file"
        echo "[KI-TOOL] Datei aktualisiert: $file"
        log_to_wiki "Pfadkorrektur in $file abgeschlossen."
    else
        rm -f "$temp_file"
    fi
}

# Funktion: Syntax prüfen und einfache Fehler beheben
check_and_fix_syntax() {
    local file="$1"
    local fixed=false

    # Bash-Syntax prüfen
    if ! bash -n "$file" >/dev/null 2>&1; then
        echo "[KI-TOOL] Syntaxfehler in $file gefunden."
        log_to_wiki "Syntaxfehler in $file gefunden."

        # Beispiel: Fehlende 'fi' einfügen
        if grep -q "if.*then" "$file" && ! grep -q "fi" "$file"; then
            echo "fi" >> "$file"
            fixed=true
            echo "[KI-TOOL] Korrektur: Fehlendes 'fi' hinzugefügt."
            log_to_wiki "Korrektur: Fehlendes 'fi' hinzugefügt in $file."
        fi

        # Prüfen, ob Korrektur erfolgreich war
        if bash -n "$file" >/dev/null 2>&1; then
            echo "[KI-TOOL] Syntaxfehler behoben in $file."
            log_to_wiki "Syntaxfehler behoben in $file."
        else
            echo "[KI-TOOL] Warnung: Syntaxfehler konnten nicht vollständig behoben werden."
            log_to_wiki "Warnung: Syntaxfehler konnten nicht vollständig behoben werden in $file."
        fi
    fi
}

# Funktion: Prüfen, ob Datei in .conf-Dateien gesourced wird
check_conf_sourcing() {
    local file="$1"
    local base_name=$(basename "$file")
    local conf_files=("$MASTER_DIR"/*.conf "$CONTROL_CONF")

    local found=false
    for conf in "${conf_files[@]}"; do
        if grep -q "source.*$base_name" "$conf"; then
            echo "[KI-TOOL] Datei $base_name wird in $conf gesourced."
            log_to_wiki "Datei $base_name wird in $conf gesourced."
            found=true
        fi
    done

    if [ "$found" = false ]; then
        echo "[KI-TOOL] Warnung: Datei $base_name wird in keiner .conf-Datei gesourced."
        log_to_wiki "Warnung: Datei $base_name wird in keiner .conf-Datei gesourced."
        # Vorschlag: In control.pv-conf einbinden
        echo "[KI-TOOL] Vorschlag: source \"$file\" in $CONTROL_CONF einfügen?"
        log_to_wiki "Vorschlag: source \"$file\" in $CONTROL_CONF einfügen."
    fi
}

# Hauptfunktion: ki scan
ki_scan() {
    local path="$1"
    if [ ! -d "$path" ]; then
        echo "[KI-TOOL] Fehler: Verzeichnis nicht gefunden: $path" >&2
        log_to_wiki "Fehler: Verzeichnis nicht gefunden: $path"
        exit 1
    fi

    echo "[KI-TOOL] Scanne Verzeichnis: $path"
    log_to_wiki "Scanne Verzeichnis: $path"

    # Alle Bash-Skripte finden (*.sh, *.shell-dna, *.cmd-dna, *.nodes, etc.)
    while IFS= read -r file; do
        echo "[KI-TOOL] Prüfe Datei: $file"
        log_to_wiki "Prüfe Datei: $file"
        check_and_fix_paths "$file"
        check_and_fix_syntax "$file"
        check_conf_sourcing "$file"
    done < <(find "$path" -type f \( -name "*.sh" -o -name "*.shell-dna" -o -name "*.cmd-dna" -o -name "*.nodes" \))
}

# Hauptfunktion: ki repair
ki_repair() {
    local path="$1"
    local file="$2"
    local full_path="$path/$file"

    if [ ! -f "$full_path" ]; then
        echo "[KI-TOOL] Fehler: Datei nicht gefunden: $full_path" >&2
        log_to_wiki "Fehler: Datei nicht gefunden: $full_path"
        exit 1
    fi

    echo "[KI-TOOL] Repariere Datei: $full_path"
    log_to_wiki "Repariere Datei: $full_path"
    check_and_fix_paths "$full_path"
    check_and_fix_syntax "$full_path"
    check_conf_sourcing "$full_path"
}

# Eingabe prüfen
if [ $# -lt 2 ]; then
    echo "[KI-TOOL] Nutzung: ki <scan|repair> <Pfad> [Datei]" >&2
    log_to_wiki "Fehler: Ungültige Eingabe. Nutzung: ki <scan|repair> <Pfad> [Datei]"
    exit 1
fi

ACTION="$1"
shift

case "$ACTION" in
    scan)
        ki_scan "$@"
        ;;
    repair)
        if [ $# -lt 2 ]; then
            echo "[KI-TOOL] Fehler: Für 'repair' wird ein Pfad und eine Datei benötigt." >&2
            log_to_wiki "Fehler: Für 'repair' wird ein Pfad und eine Datei benötigt."
            exit 1
        fi
        ki_repair "$@"
        ;;
    *)
        echo "[KI-TOOL] Ungültige Aktion: $ACTION. Verwende 'scan' oder 'repair'." >&2
        log_to_wiki "Ungültige Aktion: $ACTION. Verwende 'scan' oder 'repair'."
        exit 1
        ;;
esac
